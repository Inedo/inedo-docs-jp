---
title: Getting Started with BuildMaster
keywords: buildmaster
sequence: 10
show-related-content: false
---


## コアコンセプト  
**BuildMaster**はリリースペースを問わず、あらゆる環境でのソフトウェアリリースを継続的かつ確実なものにし、セルフサービスのリリース管理プラットフォームを構築します。

**アプリケーション** - アプリケーションは、BuildMasterでリリースしたコンポーネント、サービス、および構成で構成されています。

**パイプライン** - パイプラインを使用すことで、繰り返し可能なリリースプロセスを構築できます。ビルドの展開先となるサーバーと環境、プロセス内の段階、および任意の段階で必要な承認を定義します。

例：基本的なWebアプリケーションは、2つのステージ（テストと本番）のパイプラインを使用し、最終的にプロダクションサーバー上のフォルダーにデプロイされます。

さらに詳しく知るには  
初めてのご利用の場合には、私たちのチュートリアルをまずお試し下さい。

**リリース** - リリースとは、計画された一連の変更がテストされ、実稼働または最終的なパイプラインステージに配信されることです。

**ビルド** - リリースにデプロイされたアイテムはビルドと呼ばれます。

**構成変数** -デプロイ中に使用できるユーザー定義の静的または動的な値。

**イベントリスナー** - イベントリスナーは、指定されたイベントが発生すると、特定のアクションまたはタスク（電子メールの送信など）をトリガーします。たとえば、通知電子メールを送信するために、イベントリスナーをデプロイ後の手順としてパイプラインに追加できます。

**アーティファクト** - アーティファクトは、通常将来的なデプロイのために、コードリポジトリで実行されたプロセスの出力です。アーティファクトはビルドに関連付けられており、配布パッケージ、ログファイル、リリースノート、およびアーカイブされたソースコードを含むことができます。

# はじめに
## リリース
アプリケーションにパイプラインが完成したら、リリースを作成できます。リリースには以下の初期プロパティがあります。  
1. リリーステンプレート - リリーステンプレートが存在する場合、可変プロンプト、デフォルトパイプラインなどを決定するためにリリーステンプレートを選択できます。  
2. リリース番号 - アプリケーション内のリリースを一つ一つ識別する、1から3の部品番号（例：88、2.4、または4.1.8）。
3. リリース名 - フレンドリなリリース識別子を作成するために使用できるオプションのエイリアス。
4. パイプライン‐　ビルドの段階と承認の順序は促進されます。
5. 構成変数 - これらは実行時にデプロイメント計画で使用できます。
<span> 　/ support / documentation / proget / core-concepts / packages</span>


## ビルド
パイプラインがビルドステップを定義するように、少なくとも一つをリリースがある限り、ビルドを始めることが可能です。
下記の方法でビルドが開始されます。  
{.docs}
- リポジトリへのコミット時  
- UIの[Create Build]ボタンを使用して手動で  
- リリース＆ビルドAPI
{.docs}
ビルドのパイプラインステータスのいずれかの段階をクリックすると、次のいずれかのダイアログが表示されます。  
- ビルドのデプロイ - ビルドが前のステージに正常にデプロイされて承認された場合は、次のステージにビルドをデプロイできます。  
- 強制ビルド - ビルドが前のステージに正常にデプロイされなかった場合、または必要な承認がない場合は、そのステージで強制ビルドをおこなえます。  
- ビルドの再デプロイ - ビルドがすでにその段階に正常にデプロイされている場合は、いつでも再デプロイできます。これがビルドのロールバックを実行する方法です  

セキュリティとアクセスコントロールを使用して、どのユーザーがどの環境でこれらの操作を実行できるかを決定できます。
## ステータスとライフサイクル
ビルドには3つのステータスがあります。
{.docs}
- アクティブ - 最終ステージに展開される可能性があるパイプラインを介して進行中  
- デプロイ済み - パイプラインの最終ステージに正常にデプロイされた
- 拒否 -最終段階に不適切または不適切であると判断され、最終段階には展開されない  
ビルドがパイプラインの最終段階に正常にデプロイされると、リリースとビルドの両方のステータスが自動的にDeployedに変更されます。


# リポジトリにコミットしてビルドを開始する

BuildMasterは、自動ビルドを開始するための3つの方法をサポートしています。  
A.	リポジトリモニタ - コードリポジトリを定期的にポーリングし、最新のコミットを取得および比較して新しいビルドを開始する必要があるかどうかを判断する、ユーザー設定のBuildMasterサービス。  
B.	リポジトリフック - パイプラインで定義されたGitHubまたはGitLabリポジトリは、変更を検出するとビルドの作成を開始します。  
C.	Release＆Build API  -  TeamCity、Jenkinsなど、サードパーティのシステムからビルドを作成するための最も一般的な方法です。

注：リポジトリモニタとリポジトリフックはどちらも、プラン内で使用できる共通の変数をサポートしています。 デフォルトの変数は次のとおりです。  
$ Branch  - 最初に参照/ヘッド/なしでコミットがプッシュされた参照。 例：マスター  
$CommitHash  - コミットに関連付けられたID、SHA、またはハッシュ。例  525571720b56ca53d1d3229e774c7b7980d3ff2b



# ガイド：リポジトリモニタの設定
モニターを作成するには

[Administration]> [Repository Hooks＆Monitors]ページ、またはアプリケーションのコンテキストの[Builds]サブメニューに移動します。

以下のフィールドはすべてのモニターに適用されます。
{.docs}
- 名前 -  UIでモニターを識別するための名前  
- アプリケーション/グループの実行 - モニタのアプリケーションフィルタ  
- プラン - 新しいコミットが検出されたときに実行するデプロイプラン。モニターにプランが割り当てられていない場合は、最新のリリース用に新しいビルドが作成されます。詳細については、下記のカスタムプランを参照してください。  
- アクティブ - モニターが有効かどうかを判断します  
- スケジュール - このcronはリポジトリがポールされる頻度を決定します。デフォルト設定の '0 0/4 * * *？'の場合、4分ごとにチェックを実行します。  
- サーバー上で実行 - 指定すると、リポジトリモニターはこのサーバーを使用してリモートリポジトリに接続します。それ以外の場合は、BuildMasterサーバーからポールが実行されます。
以下の項目はGitモニターにおいて特に参照が推奨されます。  
- ブランチ  - ブランチ名と一致する正規表現の構文を使用して、監視対象のブランチを指定します。  
- 認証情報 -  Gitリポジトリへの接続に使用されるリソース認証情報  
- リポジトリURL  -  GitリポジトリのURL。デフォルトでは、これは認証情報に定義されたリポジトリーを使用するか、あるいは認証情報が利用できない場合は匿名を使用します。  
- Git実行可能パス - デフォルトでは、BuildMasterはGit接続にLibGitSharpライブラリを使用しますが、カスタム設定には代わりにGitクライアントへのパスを使用することができます（SSH接続、Gitの古いバージョンなど）。  

# Guilde：リポジトリフックを使う
BuildMasterはGitHubとGitLabによって起動されたカスタムウェブフックイベントをサポートします。  それぞれの特定のシステムに必要な設定の詳細についてはGit extension Wikiをご覧ください。
BuildMasterは特定のアプリケーションでビルドを作成するためにGitHubウェブフックイベントを受け取ることができます。

**前提条件**
GitHub WebフックをBuildMasterと統合するには、次の前提条件が必要です。
{.docs}
- 少なくとも1つのリポジトリまたは組織を持つGitHubアカウント  
- BuildMaster v6.1以降がインストールされている  
- BuildMasterサーバー上のBuildMasterのWebサイトポートに受信ファイアウォールルールを追加  

**GitHubの設定**
{.docs}
- GitHubはリポジトリまたは組織レベルでWebフックをサポートします。ほとんどの場合、単一のWebフックエンドポイントのみを構成する必要があるため、組織レベルが適しています。

Webフックを作成するには、リポジトリまたは組織の[設定]> [Webフック]セクションにアクセスします。以下のオプションを設定してください。
{.docs}
- ペイロードURL：次のステップで生成されます
- コンテンツタイプ：application / json
- 機密：安全なトークンを作成し、次のステップにそれを書き留めます
- SSL検証：セキュリティのためにこれを有効にする必要があります、ウェブサーバー上で有効な証明書- 設定が必要です
- イベント：プッシュイベントだけ
- アクティブ：チェック

**BuildMasterの設定**
BuildMasterで、Administration> Repository Hooks＆Monitorsページにアクセスしてwebhookレシーバーを追加します。 GitHubウェブフックを作成するには、以下のオプションがあります。

名前：生成されたペイロードURLの識別子としても機能する、Webhookエンドポイントを説明するわかりやすい名前。英数字、ダッシュ、および下線のみが許可されています  
アプリケーション用に実行：特定のアプリケーションが選択されている場合、そのアプリケーション内のすべてのアクティブなリリースに対してビルドが作成されます。アプリケーションが選択されていない場合は、代わりに指定されたグローバルプランが実行されます（例については下記を参照）。  
プラン：実行されるプラン。指定されている場合は適用範囲、それ以外の場合はグローバル計画  
アクティブ：非アクティブなウェブフックはビルドを作成したり指定された計画を実行したりしません  
秘密のトークン：これはGitHub側で入力された秘密のフィールドと一致しなければなりません
{.docs}
- 保存すると、BuildMasterホストに関連するペイロードURLが概要ページに表示されます。 例： api / hooks / GitHubHook。




# GitHub設定を完了する"

WebMookレシーバーがBuildMasterで作成されたら、ペイロードURLとして、パブリックにアクセス可能なBuildMasterホストを基準にしてそのURLを入力します。次に例を示します。

詳細はこちら：<https://buildmaster.inedo.com/api/hooks/GitHubHook>

Webフックが保存されると、BuildMasterはGitHubプッシュイベントを受け入れる準備が整います。

設定をテストするには、直接コミットを押すか、GitHubでページを編集後、Settings> Webhooks> Editページを使用して、BuildMasterに送信されたデータとその反応を表示します。



# Buildmasterのトラブルシューティング#
発生しがちな問題は次のとおりです。
{.docs}
- BuildMasterサーバーはインターネットからアクセスできません。：  
この場合、要求はBuildMasterから開始されるため、Repository Monitorsがより適している可能性があります

- ビルドが作成されていません。：  
カスタムプランが指定されていない場合、ビルドはアプリケーション内の最新のアクティブリリースに対してのみトリガーされます。 カスタムプランが指定されている場合は、そのプランがアプリケーションやリリースを列挙し、さらにビルドを作成します。

- ログ：  
特定のトリガーのBuildMasterログ（要求がBuildMasterに到達したと仮定した場合）は、「管理」>「実行」ページにあります。 モードで絞り込む：トリガーをビルドして表示します。  
GitHub Webhooksページには、すべてのwebhookリクエスト、リクエストボディ、レスポンスが表示され、リクエストを再送信することもできます。





# その他のBuildmasterの機能#

**バッジAPI**
BuildMasterは、外部ツールが次のような "CIバッジ"を生成するためにビルドステータスに問い合わせることを可能にします。

CIバッジAPIにアクセスするには、APIへのアクセス権を持つAPIキーを追加する必要があります。 その後、次のURLを使用してバッジイメージまたは対応するビルド/実行へのリンクを生成できます。

画像：  
{buildmaster-host} / api / ci-badges / image？API_Key = {yourApiKey}＆$ ApplicationName = {appName}  
リンク：
{buildmaster-host} / api / ci-badges / link？API_Key = {yourApiKey}＆$ ApplicationName = {appName}
バッジ指定子はアプリケーションに限定されず、コミットID、ブランチなどに基づいてさらにフィルタリングすることができます。 バッジの設定方法およびクエリ方法の詳細については、CI Badge APIのドキュメントを参照してください。
画像：
{buildmaster-host} / api / ci-badges / image？API_Key = {yourApiKey}＆$ ApplicationName = {appName}
リンク：
{buildmaster-host} / api / ci-badges / link？API_Key = {yourApiKey}＆$ ApplicationName = {appName}  
バッジ指定子はアプリケーションに限定されず、コミットID、ブランチなどに基づいてさらにフィルタリングすることができます。 バッジの設定方法および参照方法の詳細については、CI Badge APIのドキュメントを参照してください。
